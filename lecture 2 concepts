8086 Microprocessor architecture(Page 3)
1. Bus Interface Unit (BIU)
The BIU handles all communication with memory and I/O devices.
Main jobs of BIU:
Performs external bus operations (communicates with outside world).
Fetches instructions from memory.
Reads/writes data and operands from/to memory.
Handles input/output operations with peripheral devices.
Fills instruction queue (a pipeline mechanism).
Generates addresses using segment registers (CS, DS, SS, ES) + instruction pointer (IP).
 In the diagram:
Address bus & Data bus connected externally.
Address generation and bus control block.
Instruction Queue: Pre-fetches up to 6 bytes of instructions to speed execution (pipelining).
Segment Registers (CS, DS, SS, ES) + Instruction Pointer (IP) for memory addressing.

2. Execution Unit (EU)
The EU is responsible for decoding and executing instructions.
Main jobs of EU:
Decodes and executes instructions fetched by BIU.
Takes instructions from the instruction queue.
Uses data from general-purpose registers (AX, BX, CX, DX, SI, DI, BP, SP) or memory.
Generates operand addresses (then hands them to BIU).
Updates flags register (status flags like Zero, Carry, Sign, etc.) during execution.
Waits if instruction queue is empty (BIU refills it).
In the diagram:
General Registers (AH/AL, BH/BL, etc.) for computation.
Arithmetic Logic Unit (ALU) performs arithmetic & logic operations.
Flags Register stores results of operations.
How They Work Together
BIU and EU work in parallel:
BIU fetches next instructions and keeps them in the queue.
EU executes current instructions.
This parallelism (called pipelining) improves performance.
Example:
While EU is executing one instruction, BIU can already fetch the next one.

BIU = fetches, communicates, generates addresses.
EU = decodes, executes, updates flags.
Together, they allow faster execution through pipelined architecture.

Slide 5 explanation
Step-by-step Flow:
From Memory ‚Üí Update Opcode Queue
Instructions are fetched from memory into the instruction queue.
This prefetching allows overlapping of fetching and execution (pipelining).
Decode First Byte
The first byte of the instruction is taken from the queue.
The decoder checks this byte to determine:
The length of the opcode (1 byte or 2 bytes).
Updates the queue accordingly.
Is it a Single Byte Instruction?
If Yes (1-byte instruction):
The instruction is executed directly along with any required data bytes.
If No (multi-byte instruction):
The second byte is fetched from the queue.
Then the opcode is fully decoded.
Execute Instruction
Once the instruction bytes are decoded, the instruction is executed with its associated data (if any).
Repeat the Same Procedure
After execution, the next instruction in the queue is processed.
This cycle repeats for all successive instructions.

CS:IP = the exact memory address of the next instruction.
üîπ What does ‚Äúodd/even‚Äù mean here?
Memory is byte-addressable ‚Üí every address points to 1 byte.
If IP is even ‚Üí the instruction starts at an even memory boundary. In this case, the CPU assumes the instruction is 2 bytes long and 
fetches 2 bytes.
If IP is odd ‚Üí the instruction starts at an odd memory boundary. In this case, the CPU fetches only 1 byte (a single-byte instruction).



