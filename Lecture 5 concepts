1st Byte of Instruction (Opcode + Control bits)
In 8086, the first byte of instruction generally contains:
Opcode field (6 bits):
These 6 bits specify which operation is to be performed.
Example: ADD, MOV, SUB, etc. Each operation has a unique binary code.
Direction bit (D bit):
This decides the direction of data transfer (source/destination).
If D = 1 â†’ Register specified in byte 2 is destination.
If D = 0 â†’ Register specified in byte 2 is source.
Word bit (W bit):
This decides the size of the operation.
If W = 0 â†’ 8-bit operation (operand = byte register like AL, BL).
If W = 1 â†’ 16-bit operation (operand = word register like AX, BX).



ğŸ”¹ Structure of 2nd Byte (8 bits total)
It is divided into 3 fields:
MOD (2 bits) â†’ Defines addressing mode (is operand in register or memory, with/without displacement?).
REG (3 bits) â†’ Specifies a register (its role as source or destination is decided by D bit in byte 1).
R/M (3 bits) â†’ Works together with MOD to specify the second operand (register or memory address).
ğŸ”¹ 1. REG Field (3 bits)
Identifies a register operand (AX, BX, CL, etc.).
Which operand is "source" or "destination" depends on the D bit in byte 1:
D = 1 â†’ REG = destination register.
D = 0 â†’ REG = source register.
Width (8-bit or 16-bit) is decided by the W bit.
Example:
MOV AX, BX â†’ D=1 â†’ REG field = AX (destination), R/M field = BX (source).
MOV BX, AX â†’ D=0 â†’ REG field = AX (source), R/M field = BX (destination).
ğŸ”¹ 2. MOD Field (2 bits)
Specifies whether the second operand (R/M) is in a register or memory:
MOD (2 bits)	Meaning
00	Memory addressing, no displacement (just R/M gives the effective address).
01	Memory addressing with 8-bit displacement.
10	Memory addressing with 16-bit displacement.
11	Register addressing (R/M field directly specifies a register).
ğŸ”¹ 3. R/M Field (3 bits)
Interpreted depending on MOD:
If MOD = 11 â†’ R/M directly selects a register.
If MOD = 00,01,10 â†’ R/M + MOD tells which memory addressing mode is used (like [BX+SI], [BP+DI], etc.).
ğŸ”¹ Putting it All Together
So, the 2nd byte works like this:
[ MOD (2 bits) | REG (3 bits) | R/M (3 bits) ]
MOD = addressing type (register or memory, displacement or not).
REG = one operand (source/destination depends on D bit).
R/M = the other operand (register/memory, defined by MOD).
ğŸ”¹ Example
Instruction: MOV AX, [BX+SI]
Byte 1 â†’ Opcode + D + W.
Byte 2 â†’
MOD = 00 (memory without displacement)
REG = AX (selected by D bit = destination)
R/M = 000 (which means [BX+SI])
So this encodes â€œmove from memory at address [BX+SI] into AXâ€.



1. 8086 Address Bus
The 8086 microprocessor has a 20-bit address bus.
With 20 bits, we can generate 
2^20 = 1,048,576220
=1,048,576 different addresses.
That equals 1 MB of memory space.
 Memory Address Range
The first address is 00000H.
The last address is FFFFFH (20-bit maximum).
So the total memory range is from 00000H to FFFFFH = 1 MB.
3. Division into Blocks
A segment register in 8086 is 16-bit, so it can address 
2^16 = 64 ğ¾ğµ at a time.
Therefore, the whole 1 MB memory is divided into:1ğ‘€ğµ/64ğ¾ğµ = 16Â blocks


4. Block Addressing
Each block = 64 KB.
The most significant hex digit increases by 1 for each block.
Example:
Block 0 â†’ 00000H â€“ 0FFFFH
Block 1 â†’ 10000H â€“ 1FFFFH
Block 2 â†’ 20000H â€“ 2FFFFH
Block 3 â†’ 30000H â€“ 3FFFFH
...
Block F (16th block) â†’ F0000H â€“ FFFFFH
Summary:
The 8086 microprocessor can access 1 MB of memory (00000Hâ€“FFFFFH) using its 20-bit address bus. This space is divided into 16 blocks of 64 KB each, 
and the highest hex digit of the address increases by 1 for each block.
